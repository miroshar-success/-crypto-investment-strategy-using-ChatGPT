// These are the time frames you can use:
const timeFrames = {
  '1m': '1min',
  '3m': '3min',
  '5m': '5min',
  '15m': '15min',
  '30m': '30min',
  '1h': '1hour',
  '2h': '2hour',
  '4h': '4hour',
  '6h': '6hour',
  '8h': '8hour',
  '12h': '12hour',
  '1d': '1day',
  '1w': '1week'
};

const ccxt = require('ccxt');
const { Configuration, OpenAIApi } = require('openai');

// Replace EXCHANGE_NAME with the name of the exchange you want to use
const exchangeName = 'kucoin';

// Instantiate the Exchange class
const exchange = new (ccxt)[exchangeName]();

// Set sandbox mode to True or False
exchange.set_sandbox_mode(false);

// Set your API keys
exchange.apiKey = '';
exchange.secret = '';
exchange.password = '';

// Set the symbol you want to trade on Kucoin
const symbol = 'BTC/USDT';

// Start the trading script
async function startTrading() {
  try {
    while (true) {
      try {
        // Batch streaming data from KuCoin it uses a pair and a window time frame
        const data = await exchange.fetch_ohlcv(symbol, '1h', { limit: 1 });
        //console.log(data);

        // Create an infinite loop to trade continuously
        while (true) {
          // Fetch the current ticker information for the symbol
          console.log('# Fetch the current ticker information for the symbol');
          let ticker;
          try {
            ticker = await exchange.fetch_ticker(symbol);
          } catch (error) {
            continue;
          }

          // Check the current bid and ask prices
          console.log('# Check the current bid and ask prices');
          const bid = ticker.bid;
          const ask = ticker.ask;

          // Calculate the midpoint of the bid and ask prices
          console.log('# Calculate the midpoint of the bid and ask prices');
          const midpoint = (bid + ask) / 2;

          // KuCoin fee per transaction
          const fee = 0.001;

          // Set the premium for the sell order
          const premium = 0.003 + fee;

          const amount = Math.round(1 / midpoint, 3);

          // Get balance for selling
          const balance = await exchange.fetch_balance();
          const btcBalance = balance.BTC.free;
          const usdtBalance = balance.USDT.free;
          console.log(btcBalance);
          console.log(usdtBalance);

          // Market Data Print
          const currentTime = new Date();
          console.log(currentTime.toLocaleString());
          // Market Data Print

          // Ask ChatGPT if it's going up or down
          const gptUpDown = async (data) => {
            const configuration = new Configuration({
              apiKey: 'sk-',
            });
            const openai = new OpenAIApi(configuration);

            const preprompt = 'Predict: UP or DOWN (no other information).';
            console.log(preprompt);
            const cleaned = data.toString();
            const datacleaned = cleaned.replace(/[\[\]]/g, '');
            console.log(datacleaned);

            const response = await openai.createChatCompletion({
              model: 'gpt-3.5-turbo',
              max_tokens: 4000,
              n: 1,
              temperature: 0.5,
              messages: [
                { role: 'system', content: preprompt },
                { role: 'user', content: datacleaned },
              ],
            });

            const content = response.data.choices[0].message.content.trim().replace(/\n/g, '').replace(/\./g, '').toLowerCase();
            console.log(content);
            return content;
          };

          // Check if there are any open orders
          console.log('# Check if there are any open orders');
          const openOrders = await exchange.fetch_open_orders(symbol);
          if (!openOrders.length) {
            console.log('# Place a limit buy order at the midpoint price');
            try {
              // Check if it is bullish up or bearish down before buying
              if (await gptUpDown(data) === 'up') {
                // Place a limit buy order at the midpoint price
                const orderId = await exchange.create_order(symbol, 'limit', 'buy', amount, ask);
              }
            } catch (error) {
              // We must own bitcoin and we want to sell it if the script
              // tries to buy more bitcoin and has insufficient funds
              if (!openOrders.length) {
                // Check if it is bullish up or bearish down before buying
                if (await gptUpDown(data) === 'down') {
                  // Place a limit sell order at the midpoint price plus the premium which includes the fee
                  //const orderId = await exchange.create_order(symbol, 'limit', 'sell', btcBalance, midpoint * (1 + fee));
                  const orderId = await exchange.create_order(symbol, 'limit', 'sell', amount, bid);
                }
              }
            }
          }

          // Pause for a few seconds and check the status of the open orders
          console.log('# Pause for a few seconds and check the status of the open orders');
          await new Promise(resolve => setTimeout(resolve, 5000));
          try {
            openOrders = await exchange.fetch_open_orders(symbol);
          } catch (error) {
            await new Promise(resolve => setTimeout(resolve, 60000));
            openOrders = await exchange.fetch_open_orders(symbol);
          }

          // Check if there are any open orders
          console.log('# Check if there are any open orders');
          if (!openOrders.length) {
            // Place a limit sell order at the midpoint price plus the premium
            try {
              if (await gptUpDown(data) === 'down') {
                //const orderId = await exchange.create_order(symbol, 'limit', 'sell', btcBalance, midpoint * (1 + fee));
                const orderId = await exchange.create_order(symbol, 'limit', 'sell', amount, bid);
              }
            } catch (error) {
              // Place a limit buy order at the midpoint price
              // If for some reason the script doesn't have anything to sell
              // It'll just buy it
              if (await gptUpDown(data) === 'up') {
                const orderId = await exchange.create_order(symbol, 'limit', 'buy', amount, ask);
              }
            }
          }

          // Pause for a few seconds and check the status of the open orders XYZ
          console.log('# Pause for a few seconds and check the status of the open orders');
          await new Promise(resolve => setTimeout(resolve, 60 * 60 * 1000));
          try {
            openOrders = await exchange.fetch_open_orders(symbol);
          } catch (error) {
            await new Promise(resolve => setTimeout(resolve, 5000));
            openOrders = await exchange.fetch_open_orders(symbol);
          }
        }
      } catch (error) {
        // The logic for this sleeping is if the script fails for some rate limit error
        // or other issue it'll wait one minute before restarting the script again.
        await new Promise(resolve => setTimeout(resolve, 60000));
        continue;
      }
    }
  } catch (error) {
    console.error(error);
  }
}

startTrading();